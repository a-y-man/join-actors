# Fair Join Pattern Matching for Actors

## Description

This library implements join patterns in Scala 3, a coordination mechanism for concurrent message-passing programs, first introduced in the join calculus. Join patterns allow to declaratively specify how to react and synchronize distributed computations.

The library offers a convenient and safe method to define and utilize join patterns in Scala 3. It achieves this by leveraging Scala 3's metaprogramming capabilities, extending the language through the use of macros and the reflection API. We use the Scala 3 pattern matching syntax to define join patterns, and the library converts these into an internal representation using the aforementioned techniques.

Additionally, the library uses the Actor model as a practical example to demonstrate the application of join patterns. At present, we are employing a simple homemade actor model implementation.

### Code base Structure

The source code for the join patterns library is organized as follows:

- `join-patterns/core`: Contains the core implementation of the join patterns library.

  - `join-patterns/core/src/main/scala/`: Has the following sub-packages:

    - `actors`: Contains the prototype actor implementation.

    - `join_patterns`: Contains the implementation of the join pattern
      matching algorithm and code generation macros.
      - `Matcher.scala`: Contains the matcher trait that is implemented by the
        different join pattern matching algorithms.
      - `BruteForceMatcher.scala`: Contains the brute-force matcher implementation.
      - `StatefulTreeMatcher.scala`: Contains the stateful tree-based matcher implementation.

    - `examples`: Contains examples of using the join patterns library.

- `join-patterns/benchmarks`: Contains the benchmarking code for the join patterns library.

  - `join-patterns/benchmarks/src/main/scala/`: Has the following files:

    - `Benchmarks.scala`: Contains the benchmarking code for the join patterns library.

    - `SmartHouse.scala`: Contains the Smart House example used for benchmarking.

    - `Size.scala`: Contains the benchmarks for _Pattern size without guards_ benchmarks.

    - `SizeWithGuards.scala`: Contains the benchmarks for _Pattern size with guards_ benchmarks.
  - `join-patterns/benchmarks/data`: Contains the data files generated by the benchmarks.
    - The data files for each experiment are grouped in directories named after the experiment prefixed with timestamp. Generally, the structure of these directories is as follows:
      - `{{yyyy_MM_dd_HH_mm_ss}}_{{benchmark_name}}/`: Containing the following:
        - `{{benchmark_name}}_BruteForceAlgorithm.csv`: Contains the raw data for the benchmark with the brute-force algorithm.
        - `{{benchmark_name}}_StatefulTreeAlgorithm.csv`: Contains the raw data for the benchmark with the stateful tree algorithm.

### Build and Test

The library can be compiled by
installing a [Java Development Kit (version 21 or later)](https://jdk.java.net/21/)
and [sbt (version 1.9 or later)](https://www.scala-sbt.org/) and running `sbt compile`. Then, `sbt` will download
the required dependencies (including the Scala 3 compiler).

To compile the library, run the following command from the root directory (where the `build.sbt` file is located):

```bash
sbt clean compile
```

To run the tests of the core library, run the following command:

```bash
sbt core/test
```

To run for instance the `Bounded Buffer` example, run the following command:

```bash
sbt "core/run bounded-buffer -b 100 -p 10 --algorithm brute"
```
